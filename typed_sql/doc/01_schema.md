For `package:typed_sql` to offer a convinient type-safe API for writing SQL
queries we need to define the database schema and generate code from it.

## Database Schema
The schema must be defined in a single Dart library, this is typically called
`model.dart`, the generated part will be written to `model.g.dart` using
[build_runner]. Thus, we must always include this part-file as follows:
```dart
import 'package:typed_sql/typed_sql.dart';

part 'model.g.dart';
```

We must then define a _schema class_. This is an `abstract final class`
extending `Schema`, specifying what tables the database has.
If we were working on a bookstore we might define a schema as follows:

```dart schema_test.dart#schema
abstract final class Bookstore extends Schema {
  Table<Author> get authors;
  Table<Book> get books;
}
```

The _schema class_ is only allowed to have abstract getters that returns
`Table<T>` objects. Each such getter defines a table in the database.
The `T` in `Table<T>` must be a _model class_ specifying the table layout.

> [!NOTE]
> Each table must have its own _model class_. It's not possible to reuse the
> same _model class_ for multiple tables.


## Model class for `Author`
For each table in our database we must define a _model class_. This is an
`abstract final class` extending the `Model` class, specifying what fields
the database table has. Continuing with the bookstore example we can define a
_model class_ for the `authors` table as follows:

```dart schema_test.dart#author-model
@PrimaryKey(['authorId'])
abstract final class Author extends Model {
  @AutoIncrement()
  int get authorId;

  @Unique()
  String get name;
}
```

The `Author` _model class_ specifies a table with two fields:
 * `authorId`, and,
 * `name`.

The `authorId` will be a 64 bit integer, auto-incremented by default and used
as _primary key_. The `name` field will be `TEXT` and have two constraints
`NOT NULL` (because the Dart getter isn't nullable) and `UNIQUE` because of
the `@Unique()` annotation.

The equivalent SQL depends on the database, but it looks something like:
```sql
CREATE TABLE authors (
  authorId INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  UNIQUE (name)
);
```

The following data types are allowed for fields:
 * `bool`,
 * `int`,
 * `double`,
 * `String`,
 * `DateTime`,
 * `Uint8List`, and,
 * Custom subclasses of `CustomDataType<T>`.

These types are allowed to be nullable and non-nullable. When fields are
non-nullable in the Dart _model class_ the SQL table will have a `NOT NULL`
constraint. For details on [CustomDataType] see relevant documentation.

> [!NOTE]
> These model classes are intended to be data classes, they may not have
> constructors or members other than abstract public getters.
> Nor can they subclass or implement other classes.
>
> If you want to add custom helper methods, you may write extension methods for
> your model classes.


## `Book` model class with _foreign key_
Returning to our bookstore example, we still need to define a `Book`
_model class_ for the `books` table in the `Bookstore` schema. If we want the
`books` table to have a _foreign key_ refenencing the `authors` table we can
define the `Book` _model class_ as follows:

```dart schema_test.dart#book-model
@PrimaryKey(['bookId'])
abstract final class Book extends Model {
  @AutoIncrement()
  int get bookId;

  String? get title;

  @References(
    // This fields references "authorId" from "authors" table
    table: 'authors',
    field: 'authorId',

    // The reference is _named_ "author", this gives rise to a
    // Expr<Book>.author property when building queries.
    name: 'author', // optional

    // This is referenced _as_ "books", this gives rise to a
    // Expr<Author>.books property when building queries.
    as: 'books', // optional
  )
  int get authorId;

  @DefaultValue(0)
  int get stock;
}
```

The `@DefautValue(0)` annotation gives the `stock` field a default value of `0`.
This also makes the `stock` field optional when inserting rows.

> [!NOTE]
> The `name` and `as` properties in the `@References` annotation are optional.
> These gives rise to convinient subquery properties we can use when writing
> queries later.

The equivalent SQL depends on the database, but it looks something like:
```sql
CREATE TABLE books (
  bookId BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT,
  authorId BIGINT NOT NULL,
  stock BIGINT NOT NULL DEFAULT 0,
  FOREIGN KEY (authorId) REFERENCES authors (authorId)
);
```

Notice that because the `title` field is nullable, it does not have a `NOT NULL`
constraint in the database.


## Generating code
Whenever the definition of the database schema is changed, it's important to
run code generation. This is done using [build_runner]. If you don't have a
dev-dependency on `build_runner` you may add this as follows:
```sh
dart pub add dev:build_runnner
```

You can run code-generation by invoking [build_runner] as follows:
```sh
dart run build_runner build
```

This should create or update the `model.g.dart` part-file for your `model.dart`
library.


## Using the database
When we've defined a schema and generated code we can start using the database.
We must first create a `Database` instance using a `DatabaseAdaptor` and
`SqlDialect` as follows:

```dart
final db = Database<Bookstore>(adaptor, dialect);
```

How you obtain a `DatabaseAdaptor` and which `SqlDialect` to use depends on
your database, as well as how you are connecting.

Once you have `Database<Bookstore>` instance you can create empty tables for
your schema as follows:
```dart schema_test.dart#create-tables
// Create tables
await db.createTables();
```

Creating empty tables from scratch is mostly useful for testing, it's rarely
needed in production. Instead you can use the generated `create<Schema>Tables`,
which outputs the [DDL] for creating the tables.

```dart schema_test.dart#get-ddl
// Get the database schema
final ddl = createBookstoreTables(SqlDialect.postgres());
```

This can then be used with external migration management tools to managing
database migrations. See relevant documentation migrations.

> [!NOTE]
> The astute reader might notice that we never actually create an instance
> of `Bookstore` _schema class_. Instead the class is used to define a type we
> can parameterize the `Database` instance with.
> This is intentional to avoid juggling constructors, but it might be revised
> in the future.

With a `Database<Bookstore>` and tables created through migrations or
`db.createTables()` you can insert data into the database as follows:

```dart schema_test.dart#insert-data
// Insert a row into the "authors" table
final author = await db.authors
    .insert(
      name: literal('Easter Bunny'),
    )
    .returnInserted()
    .executeAndFetch(); // returns Future<Author?>

// Insert a row into the "books" table
await db.books
    .insert(
      title: literal('How to hide eggs'),
      authorId: literal(author!.authorId),
    )
    .execute();
```

Now we can also write queries against the database. The following demonstrates
how to write a query that filters on the book title and only returns `title`
and `author` name.

```dart schema_test.dart#query-data
// Query for books where the title contains 'eggs'
// select the title and author name
final titleAndAuthor = await db.books
    .where(
      (book) => book.title
          .orElseLiteral('') // because title can be null
          .toLowerCase()
          .containsLiteral('eggs'),
    )
    .select(
      (book) => (
        book.title,
        book.author.name, // use the 'author' subquery property
      ),
    )
    .fetch();

// Compare the results
check(titleAndAuthor).unorderedEquals([
  ('How to hide eggs', 'Easter Bunny'),
]);
```

The astute reader might notice that `author.name` is not actually a property on
the `books` table. However, because we defined a _foreign key_ on `Book`
_model class_ with the `@References` annotation, and gave it the name `author`,
the `Expr<Book>` expression gets a subquery property `book.author` that allows
us to access properties on the referenced `authors` row.

For more information on references see relevant documentation.

[build_runner]: https://pub.dev/packages/build_runner
[DDL]: https://en.wikipedia.org/wiki/Data_definition_language
